/**
 * React Starter Kit (https://www.reactstarterkit.com/)
 *
 * Copyright © 2014-2016 Kriasoft, LLC. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

import {
    GraphQLList as List
} from 'graphql';
import fetch from '../../core/fetch';
import NewsItemType from '../types/NewsItemType';

// React.js News Feed (RSS)
const url = 'http://ajax.googleapis.com/ajax/services/feed/load' +
    '?v=1.0&num=10&q=https://reactjsnews.com/feed.xml';

const items=[{"title":"Routing in React Native with Jake Murzy","link":"https://reactjsnews.com/routing-in-react-native-with-jake-murzy","author":"","publishedDate":"Wed, 28 Sep 2016 10:00:00 -0700","contentSnippet":"Jake Murzy has been hard at work creating a new navigational library for React Native over the last couple of months.  While ...","content":"<p>Jake Murzy has been hard at work creating a new navigational library for React Native over the last couple of months.  While React JS has the benefit of the highly-regarded React Router, such a comprehensive routing solution doesn’t exist yet in the React Native community.  In fact, React Native’s routing landscape has been in constant upheaval for the last year.  The library itself has official three ‘navigators’ for handling decision making on which components to show the user, including ‘NavigatorIOS’, ‘Navigator’, and - more recently - ‘NavigatorExperimental’.  The open source community likewise has the packages ‘React Native Router Flux’, ‘React Native Router Native’, and ‘React Native Redux Router’, which of which are in various states of completion, or, more commonly, disrepair.</p>\n\n<p><a href=\"https://github.com/jmurzy/react-router-native\">React Router Native</a> appears to focus on matching the API of the immensely popular React Router package, even going as far as introducing the concept of a URL into React Native, which bucks the notion that only web applications need or deserve a URL.</p>\n\n<hr>\n\n<p><strong>Today Jake is going to share some of his thoughts about his new library.</strong></p>\n\n<p><strong>Q:  Hi Jake!  The React Native library contains several navigation solutions and the surrounding ecosystem has multiple routing libraries.  What made you decide to make your own?</strong></p>\n\n<p>Hey! Thanks for reaching out. I’ve been eagerly watching what’s happening with navigation on React Native for a while. Until very recently, the whole Navigation scene in React Native was a mess. Navigator was being deprecated in favor of NavigationExperimental and NavigationExperimental wasn’t ready for prime time.</p>\n\n<p>My team was just starting a new project so I tried quite a few of the available solutions. Having successfully used React Router on the web, we were looking for a similar solution. Unfortunately, React Router did not support React Native, and other solutions we found were either very unstable, had a hard time keeping up with upstream changes on each release or the quality of code was quite poor.</p>\n\n<p>NavigationExperimental did most of what we wanted but it was a bit too low level so often times we found ourselves writing navigation related code and you can imagine how this gets tedious fast. The low level nature of NavigationExperimental is really by design to allow abstractions to be built up in higher layers. So to finally answer your question, the project came directly out of my frustration trying to make navigation work on React Native as good as React Router did on the web.</p>\n\n<p><strong>Q:  What is the strength of your routing system?  Is there any type of app that would be a perfect fit with React Router Native?  Conversely, is there any type of app that <em>wouldn’t</em> be a good fit with the library?</strong></p>\n\n<p>The use cases for React Router Native is pretty much the same as NavigationExperimental—which is the only supported navigation library by the React Native team. React Router Native is a very thin layer on top of NavigationExperimental that offers React Router’s mental model in a native app. Under the hood, it uses React Router for routing and NavigationExperimental for rendering user components. This is a very powerful combination that makes URLs possible on mobile.</p>\n\n<p>Most apps do not have deep-linking capabilities because implementing it for each screen in your app is a challenging task. Even within apps, users are often forced to take screenshots to share information. And for many, it’s vital that their apps support deep-linking. For example, Yelp goes as far to show a share prompt when users take screenshots of business listings. React Router Native enables developers to implement deep-linking in their apps without putting forth much effort. This can pave the way for a more connected app ecosystem.</p>\n\n<p>That being said, we’re still in the early days of React Native figuring out the right abstractions. Navigation on mobile is a challenging task, and having different flavors is only healthier as the community weighs the pros and cons of each approach rather than second guessing best-practices. So I’m hoping to get the community involved to shape the direction of the project.</p>\n\n<p><strong>Q:  Is React Router Native designed to be used with any of the official Navigation components written by the React Native team?</strong></p>\n\n<p>Absolutely. One of the primary goals of the project is that we follow React’s “learn once, write anywhere” principle. So you can use the community maintained components, interpolators and pan responders from React Native, and everything is highly customizable if you need instruct NavigationExperimental to do fancy transition animations, etc.</p>\n\n<p><strong>Q:  The React Router team has somewhat famously rewritten their API several times in the last two years, each time introducing several breaking changes.  Do you hope to keep your library at parity with React Router, breaking changes and all?  Case in point, the V4 release of React Router will introduce an all-new API.</strong></p>\n\n<p>React Router v4 is a complete rewrite. There was a lot of head-scratching on Twitter over the entire new set of breaking changes. Many people thought v4 should at best have been released under a different name. I’m not sure if I agree with that sentiment though, I understand where it is coming from. React Router v4 is a preview release, and in my opinion, it’s really hard to argue against replacing a foreign API with simple React components. I do hope to keep the library at parity with React Router, and to be honest, v4’s new everything-is-a-component approach makes the integration even easier. So over the next few weeks I’ll be working on v4 support.</p>\n\n<p><strong>Q: If you were new to React Native, which routing solution would you use?  Why?</strong></p>\n\n<p>This is a hard one to answer. Eric Vicenti has done a great job on NavigationExperimental and most of the issues have been sorted out by the community over the last few months. So if you’re familiar with Redux concepts and comfortable writing your own reducers to manage navigation state, NavigationExperimental is a great choice.</p>\n\n<p>One that I’m surprised you didn’t mention that deserves more attention is ExNavigation—another fairly new addition to the brewery. It also uses NavigationExperimental and is maintained by Adam Miskiewicz, Brent Vatne and other awesome members of the Exponent community. It feels a bit tied to the Exponent platform, but runs perfectly fine on React Native and is open source. So you’ve got that.</p>\n\n<p>Finally, If you’re just getting started with React Native and all you need is to be able to click a button and have it transition to a different scene but you don’t want it to get in your way when you need to reach in and apply complex navigational patterns, I strongly recommend you take React Router Native for a spin.</p>","categories":[]},{"title":"Playing With React and D3","link":"https://reactjsnews.com/playing-with-react-and-d3","author":"","publishedDate":"Thu, 21 Apr 2016 10:00:00 -0700","contentSnippet":"D3 is great at data visualizations, but it manipulates the DOM directly to display that data. Rendering DOM elements is where ...","content":"<p>D3 is great at data visualizations, but it manipulates the DOM directly to display that data. Rendering DOM elements is where React shines. It uses a virtual representation of the DOM (virtual DOM) and a super performant diffing algorithm in order to determine the fastest way to update the DOM. We want to leverage React’s highly efficient, declarative, and reusable components with D3’s data utility functions.</p>\n\n\n\n<p>At this point, we can safely say that  <a href=\"https://facebook.github.io/react/\">React</a> is the preferred JavaScript library for building user interfaces. It is used practically everywhere and is almost as pervasive as <a href=\"https://jquery.com/\">jQuery</a>. It has an API that is simple, powerful, and easy to learn. Its performance metrics are really impressive thanks to the Virtual DOM and its clever <a href=\"https://facebook.github.io/react/docs/reconciliation.html\">diff algorithm</a> between state changes. Nothing, however, is perfect, and React too has its limitations. One of React’s greatest strengths is the ease with which it integrate third-party libraries, but some libraries, especially opinionated ones, are more difficult to integrate than others.</p>\n\n<p>An extremely popular library that can be tricky to integrate with React is <a href=\"https://d3js.org/\">D3.js</a>. D3 is an excellent data visualization library with a rich and powerful API. It is the gold standard of data visualizations. However, Because this library is opinionated about data, it is no trivial endeavour to get it to work with React. A few simple strategies permit these two libraries to work together in very powerful ways.</p>\n\n<p><strong>Editor’s Note</strong>: Check out our upcoming workshop, <a href=\"http://bit.ly/1T0PG3b\">React and D3</a>, a crash course in learning how to create data visualizations with these two in demand libraries. Reserve your spot now on Eventbrite and get 20% off admission. Learn more at the <a href=\"http://bit.ly/1T0PG3b\">Eventbrite page</a></p>\n\n<h2>What is React?</h2>\n\n<p>React is an open-source JavaScript library for creating user interfaces that addresses the challenges of building large applications with data that changes over time. Originally developed at Facebook, it is now seen in many of the most commonly used web applications including Instagram, Netflix, Airbnb, and HelloSign.</p>\n\n<h2>Why is React so popular?</h2>\n\n<p>React helps developers build applications by helping manage the application state. It’s simple, declarative, and composable. React is not a traditional MVC framework because React is really only interested in building user interfaces. Some have called it the “V(iew)” in MVC, but that’s a little misleading. React’s viewpoint is different. As application logic has reoriented toward the client, developers have applied more structure to their front-end JavaScript. We applied a paradigm that we already understood from the server (MVC) to the browser. Of course, the browser environment is very different from the server. React acknowledges that client-side applications are really a collection of UI components that should react to events like user interaction.</p>\n\n<p>React encourages the building applications out of self-contained, reusable components that only care about a small piece of the UI. Other frameworks such as Angular also attempt to do this, but React stands out because it enforces a unidirectional data flow from parent component to child component. This makes debugging much easier. Debugging is the hardest part of application development, so while React is more verbose that other libraries or frameworks, in the end it saves a lot of time. In a framework like Angular’s, it can be hard to figure out where a bug is coming from: The view? The model? The controller? The directive? The directive controller? Data in Angular flows in many different directions, and this makes it hard to reason about that state of your application. In React, when there is a bug (and there will be!), you can quickly determine where the bug originated from because data only moves in one direction. Locating a bug is as simple as connecting the numbered dots until you find the culprit.</p>\n\n<h2>What is D3?</h2>\n\n<p>D3 (Data-Driven Documents) is a JavaScript library for producing dynamic, interactive data-visualizations. It’s fairly low level, and the developer has a lot of control over the end result. It takes a bit of work to get D3 to do what you want, so if you’re looking for a more prepackaged solution, you’re probably better off with highcharts.js. That said, it is fairly simple to pick up once you get the hang of it.</p>\n\n<p>D3 does four main things:</p>\n\n<ol>\n<li>LOADS: D3 has convenient methods for importing data from CSV documents.</li>\n<li>BINDS: D3 binds data elements to the DOM via JavaScript and SVG.</li>\n<li>TRANSFORMS: data can be adjusted to fit your visual requirements</li>\n<li>TRANSITIONS: D3 can respond to user input and animate elements based on that input</li>\n</ol>\n\n<h2>Why Would We Want To Use React with D3?</h2>\n\n<p>D3 is great at data visualizations, but it manipulates the DOM directly to display that data. Rendering DOM elements is where React shines. It uses a virtual representation of the DOM (virtual DOM) and a super performant diffing algorithm in order to determine the fastest way to update the DOM. We want to leverage React’s highly efficient, declarative, and reusable components with D3’s data utility functions. Also, once we create a chart component, we can want to be able to reuse that chart with different data anywhere in our app.</p>\n\n<h2>How to use React and D3?</h2>\n\n<p>D3, like React, is declarative.D3 uses data binding, whereas React uses a unidirectional data flow paradigm. Getting these two libraries to work together takes a bit of work, but the strategy is fairly simple: since SVG lives in the DOM, let React handle displaying SVG representations of the data and lett D3 handle all the math to render the data.</p>\n\n<p>Of course, we’ll have to make compromises. React is unopinionated and flexible, thereby allowing you to accomplish whatever needs to be done. Some tasks, like creating axes, are tedious. We can let D3 directly access the DOM and create. It handles axes well, and since we only need to create very few, this tactic won’t affect performance.</p>\n\n<p>Let’s go through a simple example. I created a repository you can use to follow along here: <a href=\"https://github.com/freddyrangel/playing-with-react-and-d3\">playing-with-react-and-d3</a>. You can follow in the <code>unfinished</code> directory and if you get stuck you can take a look at the <code>finished</code> directory.</p>\n\n<p>Let’s generate a random list of X-Y coordinates and display them on a ScatterPlot chart. If you’re following the tutorial, a finished example is provided for you under the “finished” directory, but you can also follow along under “unfinished.” I’ve gone through the trouble of doing all the setup for you. The build will automatically be created from “unfinished/src/index.jsx”</p>\n\n<p>Let’s start by creating a simple “Hello World!” React component. Create a file under “components” named “chart.jsx”</p>\n<div><pre><code><span>// unfinished/src/components/chart.jsx</span>\n<span>import</span> <span>React</span> <span>from</span> <span>'react'</span><span>;</span>\n\n<span>export</span> <span>default</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>\n  <span>return</span> <span>&lt;</span><span>h1</span><span>&gt;</span><span>Hello</span><span>,</span> <span>World</span><span>!&lt;</span><span>/h1&gt;</span><span>;\n</span><span>}</span>\n</code></pre></div>\n<p>This example is simple, but let’s go over the explanation anyway. Since we’re rendering a simple H1 with no state, we can just export a function that returns the HTML we expect. If you’re familiar with Angular or Ember, it might look weird to insert HTML directly into our JS code. On the one hand, this goes against everything we’ve learned about unobtrusive JavaScript. But on the other hand, it actually makes sense: we’re not putting JavaScript in our HTML, we’re putting our HTML into our JavaScript. React sees HTML and client-side JavaScript as fundamentally bonded together. They’re both concerned about one thing – rendering UI components to the user. They simply cannot be separated without losing the ability to see what your component is going at a glance. The great benefits of this approach is that you can describe exactly what your component will look like when it’s rendered.</p>\n\n<p>Also, keep in mind that this is only possible with JSX, which translates HTML elements into React functions that will render the HTML to the page.</p>\n\n<p>Now, let’s move on and mount our component to the DOM. Open up “index.jsx”</p>\n<div><pre><code><span>// unfinished/src/index.jsx</span>\n<span>import</span> <span>'./main.css'</span><span>;</span>\n<span>import</span> <span>React</span>    <span>from</span> <span>'react'</span><span>;</span>\n<span>import</span> <span>ReactDOM</span> <span>from</span> <span>'react-dom'</span><span>;</span>\n<span>import</span> <span>Chart</span>    <span>from</span> <span>'./components/chart.jsx'</span><span>;</span>\n\n<span>const</span> <span>mountingPoint</span> <span>=</span> <span>document</span><span>.</span><span>createElement</span><span>(</span><span>'div'</span><span>);</span>\n<span>mountingPoint</span><span>.</span><span>className</span> <span>=</span> <span>'react-app'</span><span>;</span>\n<span>document</span><span>.</span><span>body</span><span>.</span><span>appendChild</span><span>(</span><span>mountingPoint</span><span>);</span>\n<span>ReactDOM</span><span>.</span><span>render</span><span>(</span><span>&lt;</span><span>Chart</span><span>/&gt;</span><span>,</span> <span>mountingPoint</span><span>);</span>\n</code></pre></div>\n<p>You probably noticed a few things. You might be wondering why we’re requiring a CSS file. We’re using Webpack, which allows us to require CSS files. This is very useful when we  modularize both our stylesheets and our JavaScript. We’re also creating a div in which we want to mount our React app. This is just a good practice in case you want to do other things on the page then render a React component. Lastly, we’re calling <code>render</code> on ReactDOM with 2 arguments, the name of the component and the DOM element we want to mount it on.</p>\n\n<p>Now, let’s install all the dependencies by navigating to the <code>unfinished</code> directory and running <code>npm i</code>. Then, fire up the server with <code>npm run start</code> and go to <code>localhost:8080</code></p>\n\n<p><img src=\"https://reactjsnews.com/img/playing-with-react-and-d3/basic_render.png\" alt=\"Basic Render Image\"></p>\n\n<p>Awesome! We have rendered our first React component! Let’s do something a little less trivial now.</p>\n\n<p>Let’s compose some functions that will create an array of random data points and then render a <a href=\"https://en.wikipedia.org/wiki/Scatter_plot\">scatter plot</a>. While we’re at it, we’ll add a button to randomize the dataset and trigger a re-render of our app. Let’s open up our <code>Chart</code> component and add the following:</p>\n<div><pre><code><span>// unfinished/src/components/chart.jsx</span>\n<span>import</span> <span>React</span>       <span>from</span> <span>'react'</span><span>;</span>\n<span>import</span> <span>ScatterPlot</span> <span>from</span> <span>'./scatter-plot'</span><span>;</span>\n\n<span>const</span> <span>styles</span> <span>=</span> <span>{</span>\n  <span>width</span>   <span>:</span> <span>500</span><span>,</span>\n  <span>height</span>  <span>:</span> <span>300</span><span>,</span>\n  <span>padding</span> <span>:</span> <span>30</span><span>,</span>\n<span>};</span>\n\n<span>// The number of data points for the chart.</span>\n<span>const</span> <span>numDataPoints</span> <span>=</span> <span>50</span><span>;</span>\n\n<span>// A function that returns a random number from 0 to 1000</span>\n<span>const</span> <span>randomNum</span>     <span>=</span> <span>()</span> <span>=&gt;</span> <span>Math</span><span>.</span><span>floor</span><span>(</span><span>Math</span><span>.</span><span>random</span><span>()</span> <span>*</span> <span>1000</span><span>);</span>\n\n<span>// A function that creates an array of 50 elements of (x, y) coordinates.</span>\n<span>const</span> <span>randomDataSet</span> <span>=</span> <span>()</span> <span>=&gt;</span> <span>{</span>\n  <span>return</span> <span>Array</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> <span>{</span><span>length</span><span>:</span> <span>numDataPoints</span><span>}).</span><span>map</span><span>(()</span> <span>=&gt;</span> <span>[</span><span>randomNum</span><span>(),</span> <span>randomNum</span><span>()]);</span>\n<span>}</span>\n\n<span>export</span> <span>default</span> <span>class</span> <span>Chart</span> <span>extends</span> <span>React</span><span>.</span><span>Component</span><span>{</span>\n  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>\n    <span>super</span><span>(</span><span>props</span><span>);</span>\n    <span>this</span><span>.</span><span>state</span> <span>=</span> <span>{</span> <span>data</span><span>:</span> <span>randomDataSet</span><span>()</span> <span>};</span>\n  <span>}</span>\n\n  <span>randomizeData</span><span>()</span> <span>{</span>\n    <span>this</span><span>.</span><span>setState</span><span>({</span> <span>data</span><span>:</span> <span>randomDataSet</span><span>()</span> <span>});</span>\n  <span>}</span>\n\n  <span>render</span><span>()</span> <span>{</span>\n    <span>return</span> <span>&lt;</span><span>div</span><span>&gt;</span>\n      <span>&lt;</span><span>h1</span><span>&gt;</span><span>Playing</span> <span>With</span> <span>React</span> <span>and</span> <span>D3</span><span>&lt;</span><span>/h1</span><span>&gt;\n</span>      <span>&lt;</span><span>ScatterPlot</span> <span>{...</span><span>this</span><span>.</span><span>state</span><span>}</span> <span>{...</span><span>styles</span><span>}</span> <span>/</span><span>&gt;\n</span>      <span>&lt;</span><span>div</span> <span>className</span><span>=</span><span>\"controls\"</span><span>&gt;</span>\n        <span>&lt;</span><span>button</span> <span>className</span><span>=</span><span>\"btn randomize\"</span> <span>onClick</span><span>=</span><span>{()</span> <span>=&gt;</span> <span>this</span><span>.</span><span>randomizeData</span><span>()}</span><span>&gt;</span>\n          <span>Randomize</span> <span>Data</span>\n        <span>&lt;</span><span>/button</span><span>&gt;\n</span>      <span>&lt;</span><span>/div</span><span>&gt;\n</span>    <span>&lt;</span><span>/div</span><span>&gt;\n</span>  <span>}</span>\n<span>}</span>\n</code></pre></div>\n<p>Since we want our component to manage it’s own state, we need to add a bit more code than was necessary for our previous “Hello World” stateless functional component. Instead of just a function, we’re going to extend <code>React.Component</code> and describe our component in the <code>render()</code> method. <code>render()</code> is the heart of any React component. It describes what our component is supposed to looks like. React will call <code>render()</code> on initial mount and on every state change.</p>\n\n<p>Inside of <code>render()</code>, we are both rendering a scatter plot component as if it were an HTML element and setting some properties or “props”. The <code>...</code> syntax is a convenient JSX and ES2015 spread operator that spreads the attributes of an array or object instead of doing all of that explicitly. For more information check out: <a href=\"https://facebook.github.io/react/docs/jsx-spread.html\">JSX Spread Attributes</a>. We’re going to use <code>render()</code> to pass our data and a style object that will be used by some of our child components.</p>\n\n<p>In addition, we’re also rendering a button with an <code>onClick</code> event handler. We’re going to wrap <code>this.randomizeData()</code> with an arrow function and  bind the value of <code>this</code> to our <code>Chart</code> component. When the button is clicked, <code>randomizeData()</code> will call <code>this.setState()</code> and pass in some new data.</p>\n\n<p>Let’s talk about <code>this.setState()</code>. If <code>render()</code> is the heart of a React component, <code>setState()</code> is the brains of a component. <code>setState</code> explicitly tells React that we’re changing the state, thereby triggering a re-render of the component and its children. This essentially turns UI components into state machines.</p>\n\n<p>Inside of <code>setState()</code>, we’re passing an object with <code>data</code> set to the <code>randomDataSet()</code>. This means that if we want to retrieve the state of our application, we need only call <code>this.state.whateverStateWereLookingFor</code>. In this case, we can retrieve the randomData by calling <code>this.state.data</code>.</p>\n\n<p>A little side note on how React works: React offers great performance for rendering UI components by implementing a diff algorithm and comparing a virtual DOM in memory with the actual DOM. When you think about it, the DOM is really a large tree structure. If there’s one thing we have learned from decades of computer science research, it’s how to compare and manipulate trees. React takes advantage of clever tree diffing algorithms, but in order to work, each component can only render one parent element (i.e., you cannot render sibling elements). That’s why In the render function we’re wrapping all our elements in one parent div.</p>\n\n<p>Let’s get started with the scatter plot component. Create a file <code>unfinished/src/components/scatter-plot.jsx</code> :</p>\n<div><pre><code><span>// unfinished/src/components/scatter-plot.jsx</span>\n<span>import</span> <span>React</span>        <span>from</span> <span>'react'</span><span>;</span>\n<span>import</span> <span>d3</span>           <span>from</span> <span>'d3'</span><span>;</span>\n<span>import</span> <span>DataCircles</span>  <span>from</span> <span>'./data-circles'</span><span>;</span>\n\n<span>// Returns the largest X coordinate from the data set</span>\n<span>const</span> <span>xMax</span>   <span>=</span> <span>(</span><span>data</span><span>)</span>  <span>=&gt;</span> <span>d3</span><span>.</span><span>max</span><span>(</span><span>data</span><span>,</span> <span>(</span><span>d</span><span>)</span> <span>=&gt;</span> <span>d</span><span>[</span><span>0</span><span>]);</span>\n\n<span>// Returns the highest Y coordinate from the data set</span>\n<span>const</span> <span>yMax</span>   <span>=</span> <span>(</span><span>data</span><span>)</span>  <span>=&gt;</span> <span>d3</span><span>.</span><span>max</span><span>(</span><span>data</span><span>,</span> <span>(</span><span>d</span><span>)</span> <span>=&gt;</span> <span>d</span><span>[</span><span>1</span><span>]);</span>\n\n<span>// Returns a function that \"scales\" X coordinates from the data to fit the chart</span>\n<span>const</span> <span>xScale</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>\n  <span>return</span> <span>d3</span><span>.</span><span>scale</span><span>.</span><span>linear</span><span>()</span>\n    <span>.</span><span>domain</span><span>([</span><span>0</span><span>,</span> <span>xMax</span><span>(</span><span>props</span><span>.</span><span>data</span><span>)])</span>\n    <span>.</span><span>range</span><span>([</span><span>props</span><span>.</span><span>padding</span><span>,</span> <span>props</span><span>.</span><span>width</span> <span>-</span> <span>props</span><span>.</span><span>padding</span> <span>*</span> <span>2</span><span>]);</span>\n<span>};</span>\n\n<span>// Returns a function that \"scales\" Y coordinates from the data to fit the chart</span>\n<span>const</span> <span>yScale</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>\n  <span>return</span> <span>d3</span><span>.</span><span>scale</span><span>.</span><span>linear</span><span>()</span>\n    <span>.</span><span>domain</span><span>([</span><span>0</span><span>,</span> <span>yMax</span><span>(</span><span>props</span><span>.</span><span>data</span><span>)])</span>\n    <span>.</span><span>range</span><span>([</span><span>props</span><span>.</span><span>height</span> <span>-</span> <span>props</span><span>.</span><span>padding</span><span>,</span> <span>props</span><span>.</span><span>padding</span><span>]);</span>\n<span>};</span>\n\n<span>export</span> <span>default</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>\n  <span>const</span> <span>scales</span> <span>=</span> <span>{</span> <span>xScale</span><span>:</span> <span>xScale</span><span>(</span><span>props</span><span>),</span> <span>yScale</span><span>:</span> <span>yScale</span><span>(</span><span>props</span><span>)</span> <span>};</span>\n  <span>return</span> <span>&lt;</span><span>svg</span> <span>width</span><span>=</span><span>{</span><span>props</span><span>.</span><span>width</span><span>}</span> <span>height</span><span>=</span><span>{</span><span>props</span><span>.</span><span>height</span><span>}</span><span>&gt;</span>\n    <span>&lt;</span><span>DataCircles</span> <span>{...</span><span>props</span><span>}</span> <span>{...</span><span>scales</span><span>}</span> <span>/</span><span>&gt;\n</span>  <span>&lt;</span><span>/svg</span><span>&gt;\n</span><span>}</span>\n</code></pre></div>\n<p>There’s a lot going on here, so let’s start with the stateless functional component that we’re exporting. D3 uses SVG to render data visualizations. D3 has special methods for creating SVG elements and binding data to those elements – but we’re going to let React handle that. We’re creating an SVG element with the properties passed in by the <code>Chart</code> component and which can be accessed via <code>this.props</code>. Then we’re creating a <code>DataCircles</code> component (more on that below) which will render the points for the scatter plot.</p>\n\n<p>Let’s talk about D3 scales. This is where D3 shines. Scales takes care of the messy math involved in converting your data into a format that can be displayed on a chart. If you have a data point value 189281, but your chart is only 200 pixels wide, then D3 scales converts that value to a number you can use.</p>\n\n<p><code>d3.scale.linear()</code> returns a linear scale. D3 also supports other types of scales (ordinal, logarithmic, square root, etc.), but we won’t be talking about those here. <code>domain</code> is short for an “input domain”, i.e., the range of possible input values. It takes an array of the smallest input value possible and the maximum input value. <code>range</code> on its own is the range of possible output values. So in <code>domain</code>, we’re setting the range of possible data values from our random data, and in <code>range</code> we’re telling D3 the range of our chart. <code>d3.max</code> is a D3 method for determining the maximum value of a dataset. It can take a function which D3 will use to give the max values of the X and Y coordinates.</p>\n\n<p>We use the scales to render the data circles and our axes.</p>\n\n<p>Let’s create the DataCircles component under <code>unfinished/src/components/data-circles.jsx</code></p>\n<div><pre><code><span>// unfinished/src/components/data-circles.jsx</span>\n<span>import</span> <span>React</span> <span>from</span> <span>'react'</span><span>;</span>\n\n<span>const</span> <span>renderCircles</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>\n  <span>return</span> <span>(</span><span>coords</span><span>,</span> <span>index</span><span>)</span> <span>=&gt;</span> <span>{</span>\n    <span>const</span> <span>circleProps</span> <span>=</span> <span>{</span>\n      <span>cx</span><span>:</span> <span>props</span><span>.</span><span>xScale</span><span>(</span><span>coords</span><span>[</span><span>0</span><span>]),</span>\n      <span>cy</span><span>:</span> <span>props</span><span>.</span><span>yScale</span><span>(</span><span>coords</span><span>[</span><span>1</span><span>]),</span>\n      <span>r</span><span>:</span> <span>2</span><span>,</span>\n      <span>key</span><span>:</span> <span>index</span>\n    <span>};</span>\n    <span>return</span> <span>&lt;</span><span>circle</span> <span>{...</span><span>circleProps</span><span>}</span> <span>/&gt;</span><span>;\n</span>  <span>};</span>\n<span>};</span>\n\n<span>export</span> <span>default</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>\n  <span>return</span> <span>&lt;</span><span>g</span><span>&gt;</span><span>{</span> <span>props</span><span>.</span><span>data</span><span>.</span><span>map</span><span>(</span><span>renderCircles</span><span>(</span><span>props</span><span>))</span> <span>}</span><span>&lt;</span><span>/g</span><span>&gt;\n</span><span>}</span>\n</code></pre></div>\n<p>In this component, we’re rendering a <code>g</code> element, the SVG equivalent to a <code>div</code>. Since we want to render a point for every set of X-Y coordinates, were must render multiple sibling elements which we wrap together in a <code>g</code> element for React to work. Inside of <code>g</code>, we’re mapping over the data and rendering a circle for each one using <code>renderCircles</code>. <code>renderCircles</code> creates an SVG <code>circle</code> element with a number of properties. Here’s where we’re setting the x and y coordinates (<code>cx</code> and <code>cy</code> respectively) with the D3 scales passed in from the scatter plot component. <code>r</code> is the radius of our circle, and key is something React requires us to do. Since we’re rendering identical sibling components, React’s diffing algorithm needs a way to keep track of them as it updates the DOM over and over. You can use any key you like, as long as it’s unique to the list. Here we’re just going to use the index of each element.</p>\n\n<p>Now, when we look at our browser, we see this:</p>\n\n<p><img src=\"https://reactjsnews.com/img/playing-with-react-and-d3/plot_points.png\" alt=\"Plot Points Image\"></p>\n\n<p>We can see our random data and randomize that data via user input. Awesome! But we’re missing a way to read this data. What we need are axes. Let’s create them now.</p>\n\n<p>Let’s open up <code>ScatterPlot.jsx</code> and add an <code>XYAxis</code> component</p>\n<div><pre><code><span>// unfinished/src/components/scatter-plot.jsx</span>\n\n<span>// ...</span>\n\n<span>import</span> <span>XYAxis</span>       <span>from</span> <span>'./x-y-axis'</span><span>;</span>\n\n<span>// ...</span>\n\n<span>export</span> <span>default</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>\n  <span>const</span> <span>scales</span> <span>=</span> <span>{</span> <span>xScale</span><span>:</span> <span>xScale</span><span>(</span><span>props</span><span>),</span> <span>yScale</span><span>:</span> <span>yScale</span><span>(</span><span>props</span><span>)</span> <span>};</span>\n  <span>return</span> <span>&lt;</span><span>svg</span> <span>width</span><span>=</span><span>{</span><span>props</span><span>.</span><span>width</span><span>}</span> <span>height</span><span>=</span><span>{</span><span>props</span><span>.</span><span>height</span><span>}</span><span>&gt;</span>\n    <span>&lt;</span><span>DataCircles</span> <span>{...</span><span>props</span><span>}</span> <span>{...</span><span>scales</span><span>}</span> <span>/</span><span>&gt;\n</span>    <span>&lt;</span><span>XYAxis</span> <span>{...</span><span>props</span><span>}</span> <span>{...</span><span>scales</span><span>}</span> <span>/</span><span>&gt;\n</span>  <span>&lt;</span><span>/svg</span><span>&gt;\n</span><span>}</span>\n</code></pre></div>\n<p>Now, let’s create the <code>XYAxis</code> component;</p>\n<div><pre><code><span>// unfinished/src/components/x-y-axis.jsx</span>\n<span>import</span> <span>React</span>  <span>from</span> <span>'react'</span><span>;</span>\n<span>import</span> <span>Axis</span>   <span>from</span> <span>'./axis'</span><span>;</span>\n\n<span>export</span> <span>default</span> <span>(</span><span>props</span><span>)</span> <span>=&gt;</span> <span>{</span>\n  <span>const</span> <span>xSettings</span> <span>=</span> <span>{</span>\n    <span>translate</span><span>:</span> <span>`</span><span>translate</span><span>(</span><span>0</span><span>,</span> <span>$</span><span>{</span><span>props</span><span>.</span><span>height</span> <span>-</span> <span>props</span><span>.</span><span>padding</span><span>})</span><span>`</span><span>,</span>\n    <span>scale</span><span>:</span> <span>props</span><span>.</span><span>xScale</span><span>,</span>\n    <span>orient</span><span>:</span> <span>'bottom'</span>\n  <span>};</span>\n  <span>const</span> <span>ySettings</span> <span>=</span> <span>{</span>\n    <span>translate</span><span>:</span> <span>`</span><span>translate</span><span>(</span><span>$</span><span>{</span><span>props</span><span>.</span><span>padding</span><span>},</span> <span>0</span><span>)</span><span>`</span><span>,</span>\n    <span>scale</span><span>:</span> <span>props</span><span>.</span><span>yScale</span><span>,</span>\n    <span>orient</span><span>:</span> <span>'left'</span>\n  <span>};</span>\n  <span>return</span> <span>&lt;</span><span>g</span> <span>className</span><span>=</span><span>\"xy-axis\"</span><span>&gt;</span>\n    <span>&lt;</span><span>Axis</span> <span>{...</span><span>xSettings</span><span>}</span><span>/</span><span>&gt;\n</span>    <span>&lt;</span><span>Axis</span> <span>{...</span><span>ySettings</span><span>}</span><span>/</span><span>&gt;\n</span>  <span>&lt;</span><span>/g</span><span>&gt;\n</span><span>}</span>\n</code></pre></div>\n<p>For simplicity’s sake, we’re creating two objects which will hold the props for each of our X-Y axes. Let’s create an axis component to explain what these props do. Go ahead and create <code>axis.jsx</code></p>\n<div><pre><code><span>// unfinished/src/components/x-y-axis.jsx</span>\n<span>import</span> <span>React</span> <span>from</span> <span>'react'</span><span>;</span>\n<span>import</span> <span>d3</span>    <span>from</span> <span>'d3'</span><span>;</span>\n\n<span>export</span> <span>default</span> <span>class</span> <span>Axis</span> <span>extends</span> <span>React</span><span>.</span><span>Component</span> <span>{</span>\n  <span>componentDidMount</span><span>()</span> <span>{</span>\n    <span>this</span><span>.</span><span>renderAxis</span><span>();</span>\n  <span>}</span>\n\n  <span>componentDidUpdate</span><span>()</span> <span>{</span>\n    <span>this</span><span>.</span><span>renderAxis</span><span>();</span>\n  <span>}</span>\n\n  <span>renderAxis</span><span>()</span> <span>{</span>\n    <span>var</span> <span>node</span>  <span>=</span> <span>this</span><span>.</span><span>refs</span><span>.</span><span>axis</span><span>;</span>\n    <span>var</span> <span>axis</span> <span>=</span> <span>d3</span><span>.</span><span>svg</span><span>.</span><span>axis</span><span>().</span><span>orient</span><span>(</span><span>this</span><span>.</span><span>props</span><span>.</span><span>orient</span><span>).</span><span>ticks</span><span>(</span><span>5</span><span>).</span><span>scale</span><span>(</span><span>this</span><span>.</span><span>props</span><span>.</span><span>scale</span><span>);</span>\n    <span>d3</span><span>.</span><span>select</span><span>(</span><span>node</span><span>).</span><span>call</span><span>(</span><span>axis</span><span>);</span>\n  <span>}</span>\n\n  <span>render</span><span>()</span> <span>{</span>\n    <span>return</span> <span>&lt;</span><span>g</span> <span>className</span><span>=</span><span>\"axis\"</span> <span>ref</span><span>=</span><span>\"axis\"</span> <span>transform</span><span>=</span><span>{</span><span>this</span><span>.</span><span>props</span><span>.</span><span>translate</span><span>}</span><span>&gt;&lt;</span><span>/g</span><span>&gt;\n</span>  <span>}</span>\n<span>}</span>\n</code></pre></div>\n<p>Our strategy up to this point has been to let React exclusively handle the DOM. This is a good general rule, but we should leave room for nuance. In this case, the math and work necessary in order to render an axis is quite complicated and D3 has abstracted that pretty nicely. We’re going to let D3 have access to the DOM in this case. And since we’re only going to render a maximum of 2 axis, the trade-off in terms of performance is negligible.</p>\n\n<p>We’re going to create a <code>g</code> element to hand over to D3 and its DOM manipulation. <code>transform</code> is an attribute of a <code>g</code> that defines a list of transform definitions applied to an element and an element’s children. We’re passing in a <code>translate</code> attribute that moves the <code>g</code> element to where we want it. SVG is similar to canvas in that x coordinates start at the top rather than at the bottom, so we have to account for this. Otherwise, our X-Axis would be right at the top of the chart. For the Y-Axis, we want to leave some room for rendering the tickmark values.</p>\n\n<p><code>componentDidMount()</code> is a special React lifecycle method that is called immediately after the React component is mounted on the DOM. It is only called on the initial render. When this component is now rendered on the DOM, we’re going to pass a real DOM node to D3 so it can work its magic. By adding a “ref” attribute to the <code>g</code> element, we can refer to it later via <code>this.refs</code>. Every time this component is re-rendered, we want D3 to re-draw the axis. That’s where <code>componentDidUpdate()</code> comes in. It’s called every time a component is re-rendered. You can learn more about lifecycle methods <a href=\"https://facebook.github.io/react/docs/component-specs.html\">here</a>.</p>\n\n<p>Now, if we take a look at the browser again, we can see the axis, and when we randomize the data, they update automatically to reflect the changes.</p>\n\n<p><img src=\"https://reactjsnews.com/img/playing-with-react-and-d3/complete_chart.png\" alt=\"Complete Chart Image\"></p>\n\n<h2>Conclusion</h2>\n\n<p>This is but a short introduction to React and D3. If you want to learn more check out our upcoming workshop, <a href=\"http://bit.ly/1T0PG3b\">React and D3</a>, a crash course in learning how to create data visualizations with these two in demand libraries. Reserve your spot now on Eventbrite and get 20% off admission. Learn more at the <a href=\"http://bit.ly/1T0PG3b\">Eventbrite page</a></p>","categories":[]}];
const news = {
    type: new List(NewsItemType),
    resolve(abc) {
    console.log(abc.request.user);
    
//        if (lastFetchTask) {
//            return lastFetchTask;
//        }
//        console.log("resolve");
//        if ((new Date() - lastFetchTime) > 1000 * 60 * 10 /* 10 mins */ ) {
//            console.log("fetch");
//            lastFetchTime = new Date();
//            setInterval(function(){
//                lastFetchTask = fetch(url)
//                .then(response => response.json())
//                .then(data => {
//                    console.log("got",JSON.stringify(data.responseData.feed.entries));
//                    if (data.responseStatus === 200) {
//                        items = data.responseData.feed.entries;
//                    }
//
//                    return items;
//                })
//                .finally(() => {
//                    lastFetchTask = null;
//                });
//            },1000);
//            lastFetchTask = fetch(url)
//                .then(response => response.json())
//                .then(data => {
//                    console.log("got",JSON.stringify(data.responseData.feed.entries));
//                    if (data.responseStatus === 200) {
//                        items = data.responseData.feed.entries;
//                    }
//
//                    return items;
//                })
//                .finally(() => {
//                    lastFetchTask = null;
//                });
//
//            if (items.length) {
//                return items;
//            }
//
//            return lastFetchTask;
//        }

        return items;
    },
};

export default news;
